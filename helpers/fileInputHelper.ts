// helpers/fileInputHelper.ts
// File input support - generates fake files for file upload fields

import { faker } from './fakerLocale';
import { logger } from './logger';

/**
 * MIME type to file extension mapping
 */
const MIME_TO_EXT: Record<string, string> = {
  'image/png': 'png',
  'image/jpeg': 'jpg',
  'image/gif': 'gif',
  'image/webp': 'webp',
  'application/pdf': 'pdf',
  'text/plain': 'txt',
  'text/csv': 'csv',
  'application/json': 'json',
  'application/xml': 'xml'
};

/**
 * Minimal 1x1 pixel PNG (89 bytes)
 * This is the smallest valid PNG file
 */
const MINIMAL_PNG_BASE64 =
  'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';

/**
 * Minimal 1x1 pixel JPEG
 */
const MINIMAL_JPEG_BASE64 =
  '/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBEQCEAwEPwAB//9k=';

/**
 * Minimal 1x1 pixel GIF
 */
const MINIMAL_GIF_BASE64 = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

/**
 * Minimal PDF file (contains text "Test")
 */
const MINIMAL_PDF_BASE64 =
  'JVBERi0xLjQKMSAwIG9iago8PCAvVHlwZSAvQ2F0YWxvZyAvUGFnZXMgMiAwIFIgPj4KZW5kb2JqCjIgMCBvYmoKPDwgL1R5cGUgL1BhZ2VzIC9LaWRzIFszIDAgUl0gL0NvdW50IDEgPj4KZW5kb2JqCjMgMCBvYmoKPDwgL1R5cGUgL1BhZ2UgL1BhcmVudCAyIDAgUiAvTWVkaWFCb3ggWzAgMCA2MTIgNzkyXSA+PgplbmRvYmoKeHJlZgowIDQKMDAwMDAwMDAwMCA2NTUzNSBmIAowMDAwMDAwMDA5IDAwMDAwIG4gCjAwMDAwMDAwNTggMDAwMDAgbiAKMDAwMDAwMDExNSAwMDAwMCBuIAp0cmFpbGVyCjw8IC9TaXplIDQgL1Jvb3QgMSAwIFIgPj4Kc3RhcnR4cmVmCjIwMgolJUVPRgo=';

/**
 * Generate a base64 data for a specific MIME type
 */
function getFileData(mimeType: string): string {
  switch (mimeType) {
  case 'image/png':
    return MINIMAL_PNG_BASE64;
  case 'image/jpeg':
    return MINIMAL_JPEG_BASE64;
  case 'image/gif':
    return MINIMAL_GIF_BASE64;
  case 'application/pdf':
    return MINIMAL_PDF_BASE64;
  case 'text/plain':
    return btoa('This is a test file generated by Form Filler extension.');
  case 'text/csv':
    return btoa('name,email,phone\nJohn Doe,john@test.com,123-456-7890');
  case 'application/json':
    return btoa('{"name":"Test","value":123}');
  case 'application/xml':
    return btoa('<?xml version="1.0"?><root><test>value</test></root>');
  default:
    // Default to text file
    return btoa('Test file content');
  }
}

/**
 * Convert base64 to Blob
 */
function base64ToBlob(base64: string, mimeType: string): Blob {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return new Blob([bytes], { type: mimeType });
}

/**
 * Generate a fake file for the given MIME type
 */
export function generateFakeFile(mimeType = 'image/png'): File {
  const ext = MIME_TO_EXT[mimeType] || 'txt';
  const fileName = `test-${faker.string.alphanumeric(8)}.${ext}`;
  const base64Data = getFileData(mimeType);
  const blob = base64ToBlob(base64Data, mimeType);

  return new File([blob], fileName, { type: mimeType });
}

/**
 * Parse accept attribute to get allowed MIME types
 */
function parseAcceptAttribute(accept: string): string[] {
  if (!accept) return ['image/png']; // Default to PNG

  const types: string[] = [];

  accept.split(',').forEach(part => {
    const trimmed = part.trim().toLowerCase();

    // Handle file extensions
    if (trimmed.startsWith('.')) {
      const ext = trimmed.slice(1);
      switch (ext) {
      case 'png':
        types.push('image/png');
        break;
      case 'jpg':
      case 'jpeg':
        types.push('image/jpeg');
        break;
      case 'gif':
        types.push('image/gif');
        break;
      case 'webp':
        types.push('image/webp');
        break;
      case 'pdf':
        types.push('application/pdf');
        break;
      case 'txt':
        types.push('text/plain');
        break;
      case 'csv':
        types.push('text/csv');
        break;
      case 'json':
        types.push('application/json');
        break;
      case 'xml':
        types.push('application/xml');
        break;
      }
    }
    // Handle MIME types
    else if (trimmed.includes('/')) {
      // Handle wildcards like image/*
      if (trimmed === 'image/*') {
        types.push('image/png', 'image/jpeg', 'image/gif');
      } else if (trimmed === 'text/*') {
        types.push('text/plain', 'text/csv');
      } else if (trimmed === 'application/*') {
        types.push('application/pdf', 'application/json');
      } else if (MIME_TO_EXT[trimmed]) {
        types.push(trimmed);
      }
    }
  });

  // Default to PNG if no valid types found
  return types.length > 0 ? types : ['image/png'];
}

/**
 * Fill a file input with a fake file
 * @param input - The file input element
 * @returns true if successful, false otherwise
 */
export function fillFileInput(input: HTMLInputElement): boolean {
  if (input.type !== 'file') {
    return false;
  }

  try {
    // Parse accept attribute to determine file type
    const acceptAttr = input.getAttribute('accept') || '';
    const allowedTypes = parseAcceptAttribute(acceptAttr);

    // Pick a random allowed type
    const selectedType =
      allowedTypes[Math.floor(Math.random() * allowedTypes.length)] || 'image/png';

    // Generate the fake file
    const fakeFile = generateFakeFile(selectedType);

    // Create a DataTransfer to set files on the input
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(fakeFile);

    // Set the files property
    input.files = dataTransfer.files;

    // Mark as filled by extension
    input.setAttribute('data-form-filler-filled', 'true');

    // Dispatch change event
    input.dispatchEvent(new Event('change', { bubbles: true }));
    input.dispatchEvent(new Event('input', { bubbles: true }));

    logger.debug(`Filled file input with: ${fakeFile.name} (${selectedType})`);
    return true;
  } catch (error) {
    logger.warn('Failed to fill file input:', error);
    return false;
  }
}

/**
 * Get all file inputs from the document
 */
export function getAllFileInputs(): HTMLInputElement[] {
  const inputs = document.querySelectorAll<HTMLInputElement>('input[type="file"]');
  return Array.from(inputs).filter(input => !input.disabled && !input.hasAttribute('readonly'));
}
