// helpers/fileInputHelper.ts
// File input support - generates fake files for file upload fields

import { faker } from './fakerLocale';
import { logger } from './logger';

// ============ Types ============

interface FileTypeConfig {
  mimeType: string;
  extension: string;
  base64Data: string;
  category: 'image' | 'document' | 'text' | 'data';
}

// ============ File Data ============

/**
 * Minimal 1x1 pixel PNG (89 bytes)
 */
const MINIMAL_PNG_BASE64 =
  'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';

/**
 * Minimal 1x1 pixel JPEG
 */
const MINIMAL_JPEG_BASE64 =
  '/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBEQCEAwEPwAB//9k=';

/**
 * Minimal 1x1 pixel GIF
 */
const MINIMAL_GIF_BASE64 = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

/**
 * Minimal 1x1 pixel WebP
 */
const MINIMAL_WEBP_BASE64 = 'UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAQAcJYgCdAEO/hOMAA==';

/**
 * Minimal PDF file
 */
const MINIMAL_PDF_BASE64 =
  'JVBERi0xLjQKMSAwIG9iago8PCAvVHlwZSAvQ2F0YWxvZyAvUGFnZXMgMiAwIFIgPj4KZW5kb2JqCjIgMCBvYmoKPDwgL1R5cGUgL1BhZ2VzIC9LaWRzIFszIDAgUl0gL0NvdW50IDEgPj4KZW5kb2JqCjMgMCBvYmoKPDwgL1R5cGUgL1BhZ2UgL1BhcmVudCAyIDAgUiAvTWVkaWFCb3ggWzAgMCA2MTIgNzkyXSA+PgplbmRvYmoKeHJlZgowIDQKMDAwMDAwMDAwMCA2NTUzNSBmIAowMDAwMDAwMDA5IDAwMDAwIG4gCjAwMDAwMDAwNTggMDAwMDAgbiAKMDAwMDAwMDExNSAwMDAwMCBuIAp0cmFpbGVyCjw8IC9TaXplIDQgL1Jvb3QgMSAwIFIgPj4Kc3RhcnR4cmVmCjIwMgolJUVPRgo=';

/**
 * File type configurations with base64 data
 */
const FILE_TYPES: Record<string, FileTypeConfig> = {
  'image/png': {
    mimeType: 'image/png',
    extension: 'png',
    base64Data: MINIMAL_PNG_BASE64,
    category: 'image'
  },
  'image/jpeg': {
    mimeType: 'image/jpeg',
    extension: 'jpg',
    base64Data: MINIMAL_JPEG_BASE64,
    category: 'image'
  },
  'image/gif': {
    mimeType: 'image/gif',
    extension: 'gif',
    base64Data: MINIMAL_GIF_BASE64,
    category: 'image'
  },
  'image/webp': {
    mimeType: 'image/webp',
    extension: 'webp',
    base64Data: MINIMAL_WEBP_BASE64,
    category: 'image'
  },
  'application/pdf': {
    mimeType: 'application/pdf',
    extension: 'pdf',
    base64Data: MINIMAL_PDF_BASE64,
    category: 'document'
  },
  'text/plain': {
    mimeType: 'text/plain',
    extension: 'txt',
    base64Data: '', // Generated dynamically
    category: 'text'
  },
  'text/csv': {
    mimeType: 'text/csv',
    extension: 'csv',
    base64Data: '', // Generated dynamically
    category: 'data'
  },
  'application/json': {
    mimeType: 'application/json',
    extension: 'json',
    base64Data: '', // Generated dynamically
    category: 'data'
  },
  'application/xml': {
    mimeType: 'application/xml',
    extension: 'xml',
    base64Data: '', // Generated dynamically
    category: 'data'
  }
};

// ============ Utility Functions ============

/**
 * Generate dynamic text content for text-based files
 */
const generateTextContent = (mimeType: string): string => {
  switch (mimeType) {
    case 'text/plain':
      return `This is a test file generated by Form Filler extension.\nGenerated at: ${new Date().toISOString()}`;
    case 'text/csv':
      return 'name,email,phone\nJohn Doe,john@test.com,123-456-7890\nJane Smith,jane@test.com,098-765-4321';
    case 'application/json':
      return JSON.stringify({ name: 'Test', value: 123, timestamp: Date.now() }, null, 2);
    case 'application/xml':
      return (
        '<?xml version="1.0" encoding="UTF-8"?>\n<root>\n  <test>value</test>\n  <timestamp>' +
        Date.now() +
        '</timestamp>\n</root>'
      );
    default:
      return 'Test file content';
  }
};

/**
 * Get file data (base64) for a specific MIME type
 */
const getFileData = (mimeType: string): string => {
  const config = FILE_TYPES[mimeType];

  if (!config) {
    // Unknown type, return text content
    return btoa(generateTextContent('text/plain'));
  }

  // For text-based files, generate dynamic content
  if (config.category === 'text' || config.category === 'data') {
    return btoa(generateTextContent(mimeType));
  }

  return config.base64Data;
};

/**
 * Convert base64 to Blob
 */
const base64ToBlob = (base64: string, mimeType: string): Blob => {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return new Blob([bytes], { type: mimeType });
};

/**
 * Get file extension for a MIME type
 */
const getExtension = (mimeType: string): string => {
  return FILE_TYPES[mimeType]?.extension ?? 'txt';
};

// ============ Accept Attribute Parsing ============

/**
 * Extension to MIME type mapping
 */
const EXTENSION_TO_MIME: Record<string, string> = {
  png: 'image/png',
  jpg: 'image/jpeg',
  jpeg: 'image/jpeg',
  gif: 'image/gif',
  webp: 'image/webp',
  pdf: 'application/pdf',
  txt: 'text/plain',
  csv: 'text/csv',
  json: 'application/json',
  xml: 'application/xml'
};

/**
 * Parse accept attribute to get allowed MIME types
 */
const parseAcceptAttribute = (accept: string): string[] => {
  if (!accept) return ['image/png'];

  const types = new Set<string>();

  accept.split(',').forEach(part => {
    const trimmed = part.trim().toLowerCase();

    // Handle file extensions (.png, .jpg, etc.)
    if (trimmed.startsWith('.')) {
      const ext = trimmed.slice(1);
      const mimeType = EXTENSION_TO_MIME[ext];
      if (mimeType) {
        types.add(mimeType);
      }
    }
    // Handle MIME type wildcards (image/*, text/*, etc.)
    else if (trimmed.endsWith('/*')) {
      const category = trimmed.slice(0, -2);
      Object.entries(FILE_TYPES).forEach(([mime, config]) => {
        if (mime.startsWith(category + '/')) {
          types.add(config.mimeType);
        }
      });
    }
    // Handle specific MIME types
    else if (trimmed.includes('/') && FILE_TYPES[trimmed]) {
      types.add(trimmed);
    }
  });

  return types.size > 0 ? Array.from(types) : ['image/png'];
};

// ============ File Generation ============

/**
 * Generate a fake file for the given MIME type
 * @param mimeType - The MIME type of the file to generate
 * @param customFileName - Optional custom file name (without extension)
 * @returns Generated File object
 */
export function generateFakeFile(mimeType = 'image/png', customFileName?: string): File {
  const ext = getExtension(mimeType);
  const fileName = customFileName
    ? `${customFileName}.${ext}`
    : `test-${faker.string.alphanumeric(8)}.${ext}`;

  const base64Data = getFileData(mimeType);
  const blob = base64ToBlob(base64Data, mimeType);

  return new File([blob], fileName, { type: mimeType });
}

/**
 * Generate multiple fake files
 * @param count - Number of files to generate
 * @param allowedTypes - Array of allowed MIME types
 * @returns Array of generated File objects
 */
export function generateMultipleFakeFiles(
  count: number,
  allowedTypes: string[] = ['image/png']
): File[] {
  const files: File[] = [];

  for (let i = 0; i < count; i++) {
    const mimeType = allowedTypes[Math.floor(Math.random() * allowedTypes.length)] ?? 'image/png';
    files.push(generateFakeFile(mimeType));
  }

  return files;
}

// ============ Main Functions ============

/**
 * Fill a file input with fake file(s)
 * @param input - The file input element
 * @param options - Optional configuration
 * @returns true if successful, false otherwise
 */
export function fillFileInput(
  input: HTMLInputElement,
  options: { maxFiles?: number } = {}
): boolean {
  if (input.type !== 'file') {
    return false;
  }

  try {
    // Parse accept attribute to determine allowed file types
    const acceptAttr = input.getAttribute('accept') ?? '';
    const allowedTypes = parseAcceptAttribute(acceptAttr);

    // Determine number of files to generate
    const isMultiple = input.hasAttribute('multiple');
    const { maxFiles = 3 } = options;
    const fileCount = isMultiple ? faker.number.int({ min: 1, max: maxFiles }) : 1;

    // Generate files
    const files = generateMultipleFakeFiles(fileCount, allowedTypes);

    // Create DataTransfer and add files
    const dataTransfer = new DataTransfer();
    files.forEach(file => dataTransfer.items.add(file));

    // Set files on input
    input.files = dataTransfer.files;

    // Mark as filled
    input.setAttribute('data-form-filler-filled', 'true');

    // Dispatch events
    input.dispatchEvent(new Event('change', { bubbles: true }));
    input.dispatchEvent(new Event('input', { bubbles: true }));

    const fileNames = files.map(f => f.name).join(', ');
    logger.debug(`Filled file input with ${files.length} file(s): ${fileNames}`);

    return true;
  } catch (error) {
    logger.warn('Failed to fill file input:', error);
    return false;
  }
}

/**
 * Get all fillable file inputs from the document
 * @param container - Optional container to search within
 * @returns Array of file input elements
 */
export function getAllFileInputs(container: Document | HTMLElement = document): HTMLInputElement[] {
  const inputs = container.querySelectorAll<HTMLInputElement>('input[type="file"]');

  return Array.from(inputs).filter(input => {
    // Skip disabled inputs
    if (input.disabled) return false;

    // Skip already filled inputs (unless they allow multiple)
    if (input.files && input.files.length > 0 && !input.hasAttribute('multiple')) {
      return false;
    }

    // Skip hidden inputs
    const style = window.getComputedStyle(input);
    if (style.display === 'none' || style.visibility === 'hidden') {
      return false;
    }

    return true;
  });
}

/**
 * Check if a MIME type is supported
 */
export function isSupportedMimeType(mimeType: string): boolean {
  return mimeType in FILE_TYPES;
}

/**
 * Get list of supported MIME types
 */
export function getSupportedMimeTypes(): string[] {
  return Object.keys(FILE_TYPES);
}
